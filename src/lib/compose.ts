/**
 * Docker Compose file generation
 */

import { dirname, join } from "node:path";
import { existsSync, mkdirSync, readFileSync, writeFileSync } from "node:fs";
import { fileURLToPath } from "node:url";
import chalk from "chalk";
import type { ConfigPaths, InfraConfig } from "./config.js";
import { DEFAULTS } from "./config.js";

const __dirname = dirname(fileURLToPath(import.meta.url));
const ENTRYPOINT_SOURCE = join(__dirname, "..", "..", "templates", "entrypoint.ts");
const ENTRYPOINT_LOCAL = ".polyclaw/entrypoint.ts";

/**
 * Ensure entrypoint.ts is copied to the project directory
 */
function ensureEntrypoint(baseDir: string): void {
  const localDir = join(baseDir, ".polyclaw");
  const localPath = join(baseDir, ENTRYPOINT_LOCAL);

  if (!existsSync(localDir)) {
    mkdirSync(localDir, { recursive: true });
  }

  // Always copy to ensure it's up to date
  const content = readFileSync(ENTRYPOINT_SOURCE, "utf-8");
  writeFileSync(localPath, content);
}

/**
 * Generate docker-compose.yml content from configuration
 */
export function generateComposeContent(
  config: InfraConfig,
  baseDir: string
): string {
  const project = config.project;
  const image = config.docker?.image || DEFAULTS.image;

  // Keep skills path relative if it starts with ./
  const skillsPath = config.docker?.skills_path || null;

  // Ensure entrypoint is copied to project
  ensureEntrypoint(baseDir);

  let compose = `# Generated by polyclaw
# Do not edit manually - edit polyclaw.json5 and regenerate

name: ${project}

services:
`;

  for (const [name, inst] of Object.entries(config.instances)) {
    const skillsVolume = skillsPath
      ? `\n      - ${skillsPath}:/skills-custom:ro`
      : "";

    const entrypointVolume = `./${ENTRYPOINT_LOCAL}:/app/entrypoint.ts:ro`;

    // Combine global volumes + instance-specific volumes
    const globalVolumes = config.docker?.volumes || [];
    const instanceVolumes = inst.volumes || [];
    const allVolumes = [...globalVolumes, ...instanceVolumes];

    const extraVolumes = allVolumes
      .map((v) => {
        const mode = v.mode || "rw";
        return `\n      - "${v.host}:${v.container}:${mode}"`;
      })
      .join("");

    // Use env_file to pass environment variables to containers
    // Global .env/.env.shared + per-instance .env/.env.{name}
    const instanceEnvFile = `.env/.env.${name}`;
    const hasInstanceEnv = existsSync(join(baseDir, instanceEnvFile));

    const envFileLines = hasInstanceEnv
      ? `\n      - ${instanceEnvFile}`
      : "";

    // NODE_OPTIONS environment variable
    const nodeOptions = config.docker?.node_options;
    const nodeOptionsLine = nodeOptions
      ? `\n      NODE_OPTIONS: "${nodeOptions}"`
      : "";

    // Docker resource limits
    const resources = config.docker?.resources;
    let deployBlock = "";
    if (resources?.limits?.memory || resources?.reservations?.memory) {
      deployBlock = "\n    deploy:\n      resources:";
      if (resources.limits?.memory) {
        deployBlock += `\n        limits:\n          memory: ${resources.limits.memory}`;
      }
      if (resources.reservations?.memory) {
        deployBlock += `\n        reservations:\n          memory: ${resources.reservations.memory}`;
      }
    }

    // Network name depends on mode
    const networkMode = config.docker?.network || "isolated";
    const networkName = networkMode === "shared" ? `${project}-net` : `net-${name}`;

    // Shadow services.json inside the RW instance mount with a read-only bind
    // so a compromised container process cannot modify preCommands (run as root).
    const servicesVolume = `\n      - ./instances/${name}/services.json:/home/node/.openclaw/services.json:ro`;

    compose += `  ${name}:
    image: ${image}
    container_name: ${project}-${name}
    env_file:
      - .env/.env.shared${envFileLines}
    environment:
      HOME: /home/node${nodeOptionsLine}
    volumes:
      - ./instances/${name}:/home/node/.openclaw${skillsVolume}${extraVolumes}${servicesVolume}
      - ${entrypointVolume}
    ports:
      - "127.0.0.1:${inst.port}:18789"
    restart: unless-stopped
    security_opt:
      - no-new-privileges:true
    cap_drop:
      - ALL
    cap_add:
      - CHOWN
      - DAC_OVERRIDE
      - FOWNER
      - SETUID
      - SETGID${deployBlock}
    networks:
      - ${networkName}

`;
  }

  // Networks
  const networkMode = config.docker?.network || "isolated";
  compose += `networks:\n`;
  if (networkMode === "shared") {
    compose += `  ${project}-net:\n`;
  } else {
    // Isolated network per instance â€” containers cannot reach each other
    for (const name of Object.keys(config.instances)) {
      compose += `  net-${name}:\n`;
    }
  }

  return compose;
}

/**
 * Generate and write docker-compose.yml file
 */
export function generateComposeFile(
  config: InfraConfig,
  paths: ConfigPaths
): void {
  console.log(chalk.green("=== Generating docker-compose.yml ==="));

  const content = generateComposeContent(config, paths.baseDir);
  writeFileSync(paths.composeFile, content);

  const count = Object.keys(config.instances).length;
  console.log(
    `  ${chalk.green("OK")} docker-compose.yml generated with ${count} service(s)`
  );
}
