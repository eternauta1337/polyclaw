/**
 * Docker Compose file generation
 */

import { dirname, join } from "node:path";
import { existsSync, mkdirSync, readFileSync, writeFileSync } from "node:fs";
import { fileURLToPath } from "node:url";
import chalk from "chalk";
import type { ConfigPaths, InfraConfig } from "./config.js";
import { DEFAULTS } from "./config.js";

const __dirname = dirname(fileURLToPath(import.meta.url));
const ENTRYPOINT_SOURCE = join(__dirname, "..", "..", "templates", "entrypoint.ts");
const ENTRYPOINT_LOCAL = ".polyclaw/entrypoint.ts";

/**
 * Ensure entrypoint.ts is copied to the project directory
 */
function ensureEntrypoint(baseDir: string): void {
  const localDir = join(baseDir, ".polyclaw");
  const localPath = join(baseDir, ENTRYPOINT_LOCAL);

  if (!existsSync(localDir)) {
    mkdirSync(localDir, { recursive: true });
  }

  // Always copy to ensure it's up to date
  const content = readFileSync(ENTRYPOINT_SOURCE, "utf-8");
  writeFileSync(localPath, content);
}

/**
 * Generate docker-compose.yml content from configuration
 */
export function generateComposeContent(
  config: InfraConfig,
  baseDir: string
): string {
  const project = config.project;
  const image = config.docker?.image || DEFAULTS.image;

  // Keep skills path relative if it starts with ./
  const skillsPath = config.docker?.skills_path || null;

  // Ensure entrypoint is copied to project
  ensureEntrypoint(baseDir);

  let compose = `# Generated by polyclaw
# Do not edit manually - edit polyclaw.json5 and regenerate

name: ${project}

services:
`;

  for (const [name, inst] of Object.entries(config.instances)) {
    const skillsVolume = skillsPath
      ? `\n      - ${skillsPath}:/skills-custom:ro`
      : "";

    const entrypointVolume = `./${ENTRYPOINT_LOCAL}:/app/entrypoint.ts:ro`;

    // Combine global volumes + instance-specific volumes
    const globalVolumes = config.docker?.volumes || [];
    const instanceVolumes = inst.volumes || [];
    const allVolumes = [...globalVolumes, ...instanceVolumes];

    const extraVolumes = allVolumes
      .map((v) => {
        const mode = v.mode || "rw";
        return `\n      - "${v.host}:${v.container}:${mode}"`;
      })
      .join("");

    // Use env_file to pass environment variables to containers
    // Global .env/.env.shared + per-instance .env/.env.{name}
    const instanceEnvFile = `.env/.env.${name}`;
    const hasInstanceEnv = existsSync(join(baseDir, instanceEnvFile));

    const envFileLines = hasInstanceEnv
      ? `\n      - ${instanceEnvFile}`
      : "";

    compose += `  ${name}:
    image: ${image}
    container_name: ${project}-${name}
    env_file:
      - .env/.env.shared${envFileLines}
    environment:
      HOME: /home/node
    volumes:
      - ./instances/${name}:/home/node/.openclaw${skillsVolume}${extraVolumes}
      - ${entrypointVolume}
    ports:
      - "127.0.0.1:${inst.port}:18789"
    entrypoint: ["/bin/sh", "-c", "node --experimental-strip-types /app/entrypoint.ts \\"$@\\" && exec /tmp/start-services.sh", "--"]
    command: ["--bind", "lan"]
    restart: unless-stopped

`;
  }

  return compose;
}

/**
 * Generate and write docker-compose.yml file
 */
export function generateComposeFile(
  config: InfraConfig,
  paths: ConfigPaths
): void {
  console.log(chalk.green("=== Generating docker-compose.yml ==="));

  const content = generateComposeContent(config, paths.baseDir);
  writeFileSync(paths.composeFile, content);

  const count = Object.keys(config.instances).length;
  console.log(
    `  ${chalk.green("OK")} docker-compose.yml generated with ${count} service(s)`
  );
}
